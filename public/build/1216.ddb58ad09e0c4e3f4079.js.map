{"version":3,"file":"1216.ddb58ad09e0c4e3f4079.js","mappings":"4HAAA,IAAIA,GAAoCC,IACtCA,EAAiB,KAAU,OAC3BA,EAAiB,QAAa,UACvBA,IACND,GAAmB,CAAC,CAAC,EACxB,MAAME,EAAwB,mB,2KCC9B,SAASC,EAAaC,EAA8B,CAClD,OAAOC,EAAcD,EAAe,GAAI,CAC1C,CAEA,SAASC,EAAcC,EAAyB,CAC9C,OAAO,KAAK,MAAMA,EAAU,EAAE,CAChC,CAEO,SAASC,EAAoBC,EAAmBC,EAAgC,CACrF,GAAID,GAASC,EAAW,CACtB,MAAMC,EAAiBP,EAAaK,EAAM,KAAK,QAAQ,CAAC,IAAML,EAAaM,EAAU,KAAK,QAAQ,CAAC,EAC7FE,EAAeR,EAAaK,EAAM,GAAG,QAAQ,CAAC,IAAML,EAAaM,EAAU,GAAG,QAAQ,CAAC,EAE7F,MAAO,EAAEC,GAAkBC,GAE7B,MAAO,EACT,CAMA,MAAMC,EAAqB,uBAC3B,SAASC,EAAiBC,EAAuB,CAC/C,OAAOA,EAAM,QAAQF,EAAoB,MAAM,CACjD,CAMO,SAASG,EAAgCC,EAA4B,CAC1E,OAAOA,EAAW,QAAQ,MAAO,MAAM,EAAE,QAAQ,MAAO,KAAK,EAAE,QAAQ,KAAM,KAAK,CACpF,CAEO,SAASC,EAAmBD,EAA4B,CAC7D,OAAOA,EAAW,QAAQ,OAAQ;AAAA,CAAI,EAAE,QAAQ,OAAQ,GAAG,EAAE,QAAQ,QAAS,IAAI,CACpF,CAEO,SAASE,EAAgCF,EAA4B,CAC1E,OAAOD,EAAgCF,EAAiBG,CAAU,CAAC,CACrE,CAEO,SAASG,EAA2BH,EAAoBI,EAA2B,CACxF,OAAOC,EAAgBD,CAAQ,EAC3BF,EAAgCF,CAAU,EAC1CD,EAAgCC,CAAU,CAChD,CAEO,SAASK,EAAgBD,EAAmB,CACjD,MAAI,GAAAA,IAAaA,EAAS,SAAS,IAAI,GAAKA,EAAS,SAAS,IAAI,GAIpE,CAEO,SAASE,EAAcC,EAAgB,CAC5C,MAAMC,EAAiB,CACrB,IACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,IACF,EACMC,EAAQ,IAAI,OAAO,6BAA6BD,EAAe,KAAK,GAAG,KAAK,EAElF,MAAO,CAAC,CADMD,EAAO,MAAME,CAAK,CAElC,CAEO,SAASC,EAAsBC,EAAkBC,EAAmBC,EAAkC,CAC3G,GAAI,CAACD,GAASC,IAAU,OACtB,OAAO,KAGT,MAAMC,EAAYF,EAAM,OAAO,KAAMG,GAAUA,EAAM,OAAS,YAAY,GAAG,OAAOF,CAAK,EACzF,GAAI,CAACC,EACH,OAAO,KAET,OAAQA,EAAUH,CAAQ,EAAG,CAC3B,IAAK,IACH,OAAO,KAAU,QACnB,IAAK,IACH,OAAO,KAAU,mBACnB,IAAK,IACH,OAAO,KAAU,OACnB,QACE,OAAO,IACX,CACF,CAEO,MAAMK,EAA2D,CACtE,CAAC,KAAsB,KAAK,EAAG,IAC/B,CAAC,KAAsB,QAAQ,EAAG,KAClC,CAAC,KAAsB,UAAU,EAAG,KACpC,CAAC,KAAsB,aAAa,EAAG,IACzC,EAGaC,KAA2B,UAAOD,CAAiB,EAEzD,SAASE,EAAoBC,EAAwC,CAC1E,MAAMC,EAAOD,EAAgB,cAC1B,IAAKf,GAAmC,CACvC,MAAMiB,EAAWL,EAAkBZ,EAAS,QAAQ,EACpD,OAAIiB,EACK,GAAGjB,EAAS,OAAOiB,KAAYjB,EAAS,SAExC,EAEX,CAAC,EACA,OAAQkB,GAAcA,IAAM,EAAE,EAC9B,KAAK,IAAI,EAEZ,OAAOF,EAAO,IAAIA,KAAU,EAC9B,CAEO,SAASG,EAAcC,EAA0C,CACtE,MAAMC,EAA2C,CAAC,EAClDD,EAAO,QAASE,GAAU,CACxB,OAAO,KAAKA,CAAK,EAAE,QAASC,GAAQ,CAC7BF,EAASE,CAAG,IACfF,EAASE,CAAG,EAAI,IAAI,KAEjBF,EAASE,CAAG,EAAE,IAAID,EAAMC,CAAG,CAAC,GAC/BF,EAASE,CAAG,EAAE,IAAID,EAAMC,CAAG,CAAC,CAEhC,CAAC,CACH,CAAC,EAED,MAAMC,EAA0C,CAAC,EACjD,OAAAC,EAAiB,OAAO,KAAKJ,CAAQ,CAAC,EAAE,QAASE,GAAQ,CACvDC,EAAWD,CAAG,EAAIE,EAAiB,MAAM,KAAKJ,EAASE,CAAG,CAAC,CAAC,CAC9D,CAAC,EAEM,CAAE,OAAQC,EAAY,KAAM,OAAO,KAAKA,CAAU,CAAE,CAC7D,CAGO,MAAME,EAAoB,IAC1B,SAASD,EAAiBE,EAAiB,CAChD,OAAOA,EAAM,MAAM,EAAGD,CAAiB,CACzC,C,qNCzJO,MAAME,EAAmB,CAAC,CAC/B,SAAAC,EACA,MAAApB,EACA,YAAAqB,EACA,MAAApC,EACA,MAAAqC,EACA,WAAAC,EACA,cAAAC,CACF,IAA6C,CAC3C,KAAM,CAACC,EAAOC,CAAQ,KAAI,YAGvB,CAAC,CAAC,EAEL,OACE,gBAACC,EAAA,IACC,QAASC,EAAoBP,EAAarB,CAAK,EAC/C,UAAWf,IAAU,GACrB,gBAAe,GACf,WAAY,SAAY,CACtByC,EAAS,CAAE,UAAW,EAAK,CAAC,EAC5B,MAAMG,EAAU,MAAMC,EAAkBR,EAAOC,EAAYC,CAAa,EACxEE,EAAS,CAAE,QAAAG,EAAS,UAAW,MAAU,CAAC,CAC5C,EACA,UAAWJ,EAAM,UACjB,iBAAgB,GAChB,iBAAiB,kBACjB,eAAe,iBACf,QAASA,EAAM,QACf,MAAOM,EAAS9C,CAAK,EACrB,SAAWA,GAAUmC,EAASpB,EAAOf,EAAM,KAAM,EACnD,CAEJ,EAEA,eAAe6C,EACbR,EACAC,EACAC,EAC4B,CAC5B,IAAIb,EAAoCW,EAAM,OAE9C,MAAMU,EAAcR,EAAc,aAAab,CAAM,EAC/CsB,EAAS,MAAMV,EAAW,iBAAiB,kBAAkBS,CAAW,EAE9E,OAAO,OAAO,KAAKC,CAAM,EAAE,IAAKC,IAAO,CACrC,MAAOA,EACP,MAAOA,CACT,EAAE,CACJ,CAEA,MAAMH,EACJ9C,IACkE,CAAE,MAAOA,GAAO,SAAS,EAAG,MAAAA,CAAM,G,eCjD/F,SAASkD,EACdC,EACAC,EACiC,CACjC,MAAMC,EAAS,CAACC,EAAuB,CAAC,EAClCC,EAAgB,CAAC,SAAS,EAChC,IAAIC,EAEJ,OAAIL,IAAS,KAAgB,mBAC3BI,EAAc,KAAK,MAAM,EACzBF,EAAO,KAAK,CACV,KAAM,WACN,KAAM,QACR,CAAC,GAGCD,IACFC,EAAO,KAAK,CACV,KAAM,WACN,KAAM,SACN,UAAW,GACX,SAAU,EACZ,CAAC,EAEDG,EAAsBC,EAAuB,KAAKN,MAAS,GAGtD,CACL,GAAIA,EACJ,KAAMO,EAA4BP,CAAI,EACtC,OAAAE,EACA,cAAAE,EACA,gBAAiB,iBACjB,SAAU,KAAiC,eAC3C,UAAW,KAAmB,oBAC9B,SAAUI,EACV,oBAAqBC,EACrB,oBAAAJ,EACA,eAAgB,CAACK,EAAIC,IAAQ,CAC3B,IAAIC,EAAS,KAAU,KAAMd,GAAMA,EAAE,aAAeY,EAAG,EAAE,GAAG,eAAiB,GAE7E,OAAIA,EAAG,OAAO,CAAC,IAAM,UACZ,GAAGE,uQAEH,GAAGA,yHAA8HF,EAAG,OAAO,CAAC,MAEvJ,CACF,CACF,CAEO,SAASG,EAAiCb,EAAiD,CAChG,MAAMc,EAAiBf,EAAqBC,EAAM,EAAI,EAEhDE,EAASY,EAAe,OAAO,MAAM,EAAG,EAAE,EAiDhD,MAhDsD,CACpDA,EACA,CACE,GAAI,KAAKd,OACT,KAAM,GAAGO,EAA4BP,CAAI,OACzC,OAAQ,CACN,GAAGE,EACH,CACE,KAAM,QACN,KAAM,SACN,UAAW,GACX,SAAU,GACV,OAAQnB,CACV,CACF,EACA,cAAe,CAAC,GAAG+B,EAAe,cAAe,EAAE,EACnD,gBAAiB,+BACjB,SAAU,KAAiC,eAC3C,SAAUC,EAAwCf,EAAM,IAAI,EAC5D,oBAAqBgB,EAA2BhB,CAAI,EACpD,eAAgBiB,EAAwBjB,EAAM,IAAI,EAClD,oBAAqBS,EACrB,aAAc,EAChB,EACA,CACE,GAAI,KAAKT,YACT,KAAM,GAAGO,EAA4BP,CAAI,YACzC,OAAQ,CACN,GAAGE,EACH,CACE,KAAM,QACN,KAAM,SACN,UAAW,GACX,SAAU,GACV,OAAQnB,CACV,CACF,EACA,cAAe,CAAC,GAAG+B,EAAe,cAAe,EAAE,EACnD,gBAAiB,+BACjB,SAAU,KAAiC,eAC3C,SAAUC,EAAwCf,EAAM,SAAS,EACjE,oBAAqBgB,EAA2BhB,CAAI,EACpD,eAAgBiB,EAAwBjB,EAAM,SAAS,EACvD,oBAAqBS,EACrB,aAAc,EAChB,CACF,CAGF,CAEO,SAASM,EAAwCG,EAAqBC,EAA4B,CACvG,OAAO,SACLC,EACAT,EACAU,EACA,CACA,MAAMC,EAAiBX,EAAI,OAAO,UAAWY,GAAUA,EAAM,SAAS,EAChErB,EAASkB,EAAM,OAAO,MAAM,EAAGE,CAAc,EAC7CE,EAAaJ,EAAM,OAAO,MAAME,CAAc,EAEpD,OAAIpB,EAAO,SAAW,GAAKgB,IAAgB,KAAgB,iBAClD,GAAGA,KAAehB,EAAO,CAAC,MAAMmB,MAAcnB,EAAO,CAAC,OAAOiB,MAAaK,EAAW,KAAK,IAAI,KAGhG,GAAGN,KAAeG,MAAcnB,EAAO,CAAC,OAAOiB,MAAaK,EAAW,KAAK,IAAI,IACzF,CACF,CAEA,SAAShB,EACPY,EACAT,EACAU,EACA,CACA,MAAMnB,EAASkB,EAAM,QAAU,CAAC,EAC1BK,EAAcvB,EAAO,CAAC,GAAK,UAEjC,GAAIA,EAAO,SAAW,GAAKkB,EAAM,KAAO,KAAgB,iBAAkB,CACxE,MAAMM,EAAWxB,EAAO,CAAC,EACzB,MAAO,GAAGkB,EAAM,MAAMM,MAAaL,MAAcI,MAGnD,MAAO,GAAGL,EAAM,MAAMC,MAAcnB,EAAO,CAAC,GAAK,aACnD,CAEO,SAASyB,EACdP,EACAT,EACAU,EACA,CAGA,MAFyB,CAAC,IAAK,KAAM,IAAK,IAAI,EAEzB,SAAS,OAAOD,EAAM,OAAO,CAAC,CAAC,CAAC,EAC5C,GAAGC,OAAeD,EAAM,OAAO,CAAC,KAAKA,EAAM,OAAO,CAAC,KAAKA,EAAM,OAAO,CAAC,IAGxE,GAAGC,OAAeD,EAAM,OAAO,CAAC,KAAKA,EAAM,OAAO,CAAC,OAAOA,EAAM,OAAO,CAAC,KACjF,CAEO,SAASQ,EACdC,EACAC,EACS,CACT,GAAI,CAACD,EACH,MAAO,GAET,MAAME,EAAsBF,EAAU,OAAO,CAAC,EAAE,SAAS,EAAE,WAAW,GAAG,EAmBzE,OAjBmBC,EAAgB,OAChCE,GACCA,EAAe,KAAO,KAAgB,aACtCA,EAAe,OAAO,CAAC,IAAMH,EAAU,OAAO,CAAC,GAC/CG,EAAe,OAAO,CAAC,IAAMH,EAAU,OAAO,CAAC,CACnD,EAE4B,KAAMI,GAC5B,GAAAF,GAAuBE,EAAU,OAAO,CAAC,EAAE,SAAS,EAAE,WAAW,GAAG,IAAM,IAG1EF,IAAwB,IAASE,EAAU,OAAO,CAAC,EAAE,SAAS,EAAE,WAAW,GAAG,EAInF,CAGH,CAEO,SAASC,EACdd,EACAT,EACAU,EACA,CACA,OAAQD,EAAM,GAAI,CAChB,KAAK,KAAgB,OACnB,KAAM,CAACe,EAAS,GAAOC,EAAY,GAAO,GAAG7D,CAAM,EAAI6C,EAAM,OAC7D,MAAO,GAAGC,aAAqBc,EAAS,YAAc,KAAKC,EAAY,gBAAkB,MAAM7D,EAC5F,OAAQE,GAAUA,CAAK,EACvB,KAAK,IAAI,IAAI,KAAK,EACvB,KAAK,KAAgB,KACnB,MAAO,GAAG4C,YAAoBD,EAAM,OAAO,OAAQG,GAAUA,CAAK,EAAE,KAAK,IAAI,IAAI,KAAK,EACxF,KAAK,KAAgB,KACnB,MAAO,GAAGF,YAAoBD,EAAM,OAAO,OAAQG,GAAUA,CAAK,EAAE,KAAK,IAAI,IAAI,KAAK,EACxF,KAAK,KAAgB,KACnB,MAAO,GAAGF,YAAoBD,EAAM,OAAO,OAAQG,GAAUA,CAAK,EAAE,KAAK,IAAI,IAAI,KAAK,EACxF,QACE,MAAO,GAAGF,OAAeD,EAAM,IACnC,CACF,CAEA,SAASiB,EAAsB1B,EAAsC,CACnE,OAAOA,EAAI,WAAa,KAAiC,cAC3D,CAEA,SAAS2B,EACPC,EACAnD,EACAoD,EACA,CACA,MAAM5E,EAAQ2E,EAAW,UAAWzC,GAAM,CACxC,MAAM2C,EAAQrD,EAAc,uBAAuBU,EAAE,EAAE,EACvD,OAAK2C,EAGED,EAAUC,CAAK,EAFb,EAGX,CAAC,EAED,OAAO7E,IAAU,GAAK2E,EAAW,OAAS3E,CAC5C,CAEO,SAAS6C,EACdE,EACAzB,EACAwD,EACiB,CACjB,MAAMC,EAAsC,CAC1C,GAAIhC,EAAI,GACR,OAAQA,EAAI,aACd,EAEM4B,EAAa,CAAC,GAAGrD,EAAM,UAAU,EAEjC0D,EAA8BL,EAAW,KAAMzC,GAAM,CACzD,MAAM2C,EAAQC,EAAS,uBAAuB5C,EAAE,EAAE,EAClD,OAAK2C,EAGEJ,EAAsBI,CAAK,EAFzB,EAGX,CAAC,EAED,OAAQ9B,EAAI,SAAU,CACpB,KAAK,KAAiC,aACtC,KAAK,KAAiC,UAEpC,GAAI,CAACiC,EAA6B,CAChC,MAAMC,EAAgBP,EACpBC,EACAG,EACC/B,GAAQA,EAAI,WAAa,KAAiC,SAC7D,EACA4B,EAAW,OAAOM,EAAe,EAAG,CAAE,GAAI,KAAgB,KAAM,OAAQ,CAAC,SAAS,CAAE,CAAC,EAEvFN,EAAW,KAAKI,CAAY,EAC5B,MACF,KAAK,KAAiC,eAEpC,GAAIC,EAA6B,CAC/B,MAAMhF,EAAQ2E,EAAW,QAAQK,CAA2B,EAC5DL,EAAW3E,CAAK,EAAI+E,EACpB,MAIJ,QACE,MAAME,EAAgBP,EACpBC,EACAG,EACC5C,IAAOa,EAAI,WAAa,MAAQb,EAAE,WAAa,IAClD,EACAyC,EAAW,OAAOM,EAAe,EAAGF,CAAY,EAChD,KACJ,CAEA,MAAO,CACL,GAAGzD,EACH,WAAAqD,CACF,CACF,CAEO,SAASO,EAAsBnC,EAAsCzB,EAAyC,CACnH,MAAO,CACL,GAAGA,EACH,cAAe,CACb,GAAIA,EAAM,eAAiB,CAAC,EAC5B,CACE,SAAU,IACV,MAAAA,CACF,CACF,CACF,CACF,CAEO,SAAS6D,EAAsBlB,EAAmBmB,EAA2B,CAClF,OAAO,SACL5B,EACAT,EACAU,EACA,CACA,MAAM4B,EAAe7B,EAAM,OAAO,KAAMG,GAAU,OAAOA,GAAU,UAAYA,EAAM,SAAS,GAAG,CAAC,EAC5F2B,EAAYD,EAAe,IAAM,IACvC,IAAI/C,EAQJ,OAPI+C,EACF/C,EAASkB,EAAM,OAAO,IAAKG,GACzB,OAAOA,GAAU,YAAW,MAAgCA,CAAK,EAAIA,CACvE,EAEArB,EAASkB,EAAM,OAEb4B,EACK,GAAG3B,KAAaQ,KAAaqB,QAAgBhD,EAAO,KAAK,GAAGgD,QAAgBA,OAAe,IAAIA,IAEjG,GAAG7B,KAAaQ,KAAaqB,IAAYhD,EAAO,KAAK,GAAGgD,QAAgBA,GAAW,IAAIA,GAChG,CACF,CACA,SAAS/C,GAAwD,CAC/D,MAAO,CACL,KAAM,QACN,KAAM,SACN,QAAS,CAAC,UAAW,KAAM,KAAM,MAAO,KAAM,KAAK,CACrD,CACF,CAEO,SAASX,EAAoBP,EAAqBkE,EAAoB,CAC3E,MAAO,cAAclE,WAAqBkE,GAC5C,CAEO,SAAS7C,EAAuB8C,EAA6B,CAClE,OAAO,SAAwBxF,EAAe8C,EAA2BC,EAAsC,CAI7G,OAAID,EAAG,OAAO,SAAWC,EAAI,OAAO,OAC3B,CACL,GAAGD,EACH,GAAI0C,CACN,EAEK1C,CACT,CACF,CAKO,SAASO,EAAwBoC,EAAyBC,EAA6B,CAC5F,OAAO,SAA8BlC,EAA8B,CACjE,MAAM7C,EAAS6C,EAAM,OAAO,IAAK3C,GAAU,KAAKA,KAAS,EAAE,KAAK,OAAO,EACjE8E,EAAY,IAAU,QAASnC,EAAM,OAAO,MAAM,EAExD,OAAQkC,EAAM,CACZ,IAAK,KACH,MAAO,cAAcD,sCAAoDE,KAAahF,KACxF,IAAK,UACH,MAAO,cAAc8E,yBAAuC9E,qCAC9D,QACE,MAAO,cAAc8E,wBACzB,CACF,CACF,CAKO,SAASrC,EAA2BoC,EAA6B,CACtE,OAAO,SAAwBxF,EAAe8C,EAA2BC,EAAsC,CAG7G,OAAID,EAAG,OAAO,OAASC,EAAI,OAAO,OACzB,CACL,GAAGD,EACH,GAAI0C,CACN,EAGK1C,CACT,CACF,CAEO,SAASH,EAA4BiD,EAAkB,CAC5D,SAAO,cAAWA,EAAS,QAAQ,KAAM,GAAG,CAAC,CAC/C,CAEO,SAASC,EAAkD9C,EAAsCzB,EAAU,CAChH,MAAMyD,EAAsC,CAC1C,GAAIhC,EAAI,GACR,OAAQA,EAAI,aACd,EAEA,MAAO,CACL,GAAGzB,EACH,WAAY,CAAC,GAAGA,EAAM,WAAYyD,CAAY,CAChD,CACF,CAEO,SAASe,EACd1D,EACA2D,EAAsD,CAAC,EACpB,CAoEnC,MAnEsD,CACpD,CACE,GAAI3D,EACJ,KAAMO,EAA4BP,CAAI,EACtC,OAAQ,CACN,CACE,KAAM,WACN,KAAM,SACN,UAAW,GACX,SAAU,EACZ,CACF,EACA,cAAe,CAAC,EAChB,gBAAiB,qBACjB,SAAU,KAAiC,aAC3C,SAAU4D,EACV,oBAAqBtD,EAAuB,KAAKN,MAAS,EAC1D,eAAgBiB,EAAwBjB,EAAM,EAAE,EAChD,oBAAqByD,EACrB,GAAGE,CACL,EACA,CACE,GAAI,KAAK3D,OACT,KAAM,GAAGO,EAA4BP,CAAI,OACzC,OAAQ,CACN,CACE,KAAM,QACN,KAAM,SACN,UAAW,GACX,SAAU,GACV,OAAQjB,CACV,CACF,EACA,cAAe,CAAC,EAAE,EAClB,gBAAiB,kBACjB,SAAU,KAAiC,aAC3C,SAAU8E,EAAyB7D,CAAI,EACvC,oBAAqBgB,EAA2BhB,CAAI,EACpD,eAAgBiB,EAAwBjB,EAAM,IAAI,EAClD,oBAAqByD,EACrB,aAAc,GACd,GAAGE,CACL,EACA,CACE,GAAI,KAAK3D,YACT,KAAM,GAAGO,EAA4BP,CAAI,YACzC,OAAQ,CACN,CACE,KAAM,QACN,KAAM,SACN,UAAW,GACX,SAAU,GACV,OAAQjB,CACV,CACF,EACA,cAAe,CAAC,EAAE,EAClB,gBAAiB,kBACjB,SAAU,KAAiC,aAC3C,SAAU+E,EAA8B9D,CAAI,EAC5C,oBAAqBgB,EAA2BhB,CAAI,EACpD,eAAgBiB,EAAwBjB,EAAM,SAAS,EACvD,oBAAqByD,EACrB,aAAc,GACd,GAAGE,CACL,CACF,CAGF,CAEA,SAASG,EAA8B5C,EAAqB,CAC1D,OAAO,SACLE,EACAT,EACAU,EACA,CACA,MAAO,GAAGH,aAAuBE,EAAM,OAAO,KAAK,IAAI,OAAOC,IAChE,CACF,CAEO,SAASuC,EACdxC,EACAT,EACAU,EACA,CACA,MAAMnB,EAAS6D,EAAa3C,EAAOT,EAAKU,CAAS,EAC3C2C,EAAM5C,EAAM,GAAK,IAEvB,OAAIC,GACFnB,EAAO,KAAKmB,CAAS,EAGhB2C,EAAM9D,EAAO,KAAK,IAAI,EAAI,GACnC,CAEA,SAAS6D,EAAa3C,EAA8BT,EAAsCU,EAAmB,CAC3G,OAAQD,EAAM,QAAU,CAAC,GAAG,IAAI,CAACvE,EAAOe,IACrB+C,EAAI,OAAO/C,CAAK,EACpB,OAAS,SACb,IAAMf,EAAQ,IAGhBA,CACR,CACH,CAEA,SAASgH,EAAyB3C,EAAqB,CACrD,OAAO,SACLE,EACAT,EACAU,EACA,CACA,MAAO,GAAGH,QAAkBE,EAAM,OAAO,KAAK,IAAI,OAAOC,IAC3D,CACF,CAEO,SAAS4C,EACdjE,EACAkE,EACAP,EAAsD,CAAC,EACpB,CACnC,MAAMpB,EAAamB,EAA2B1D,EAAM2D,CAAS,EAC7D,OAAApB,EAAW,CAAC,EAAE,OAAO,QAAQ,GAAG2B,EAAU,MAAM,EAChD3B,EAAW,CAAC,EAAE,OAAO,QAAQ,GAAG2B,EAAU,MAAM,EAChD3B,EAAW,CAAC,EAAE,OAAO,QAAQ,GAAG2B,EAAU,MAAM,EAChD3B,EAAW,CAAC,EAAE,cAAgB2B,EAAU,cACxC3B,EAAW,CAAC,EAAE,cAAgB,CAAC,GAAG2B,EAAU,cAAe,EAAE,EAC7D3B,EAAW,CAAC,EAAE,cAAgB,CAAC,GAAG2B,EAAU,cAAe,EAAE,EAC7D3B,EAAW,CAAC,EAAE,SAAW4B,EAAsCnE,CAAI,EACnEuC,EAAW,CAAC,EAAE,SAAW4B,EAAsCnE,CAAI,EAC5DuC,CACT,CAEA,SAAS4B,EAAsCjD,EAAqB,CAClE,OAAO,SACLE,EACAT,EACAU,EACA,CACA,MAAMC,EAAiBX,EAAI,OAAO,UAAWY,GAAUA,EAAM,SAAS,EAChErB,EAASkB,EAAM,OAAO,MAAM,EAAGE,CAAc,EAC7CE,EAAaJ,EAAM,OAAO,MAAME,CAAc,EAEpD,MAAO,GAAGJ,QAAkBM,EAAW,KAAK,IAAI,OAAOtB,EACpD,IAAI,CAACqB,EAAO6C,IAASzD,EAAI,OAAOyD,CAAG,EAAE,OAAS,SAAW,IAAK7C,KAAYA,CAAM,EAChF,KAAK,IAAI,MAAMF,IACpB,CACF,C,uFCtiBYgD,GAAAA,IACVA,EAAA,IAAM,MACNA,EAAA,OAAS,SAFCA,IAAAA,GAAA,IAWAC,GAAAA,IACVA,EAAA,aAAe,eACfA,EAAA,eAAiB,kBACjBA,EAAA,UAAY,YACZA,EAAA,QAAU,UACVA,EAAA,YAAc,eACdA,EAAA,aAAe,gBACfA,EAAAA,EAAA,UAAY,GAAqB,EAAjC,YAPUA,IAAAA,GAAA,IAUAC,GAAAA,IACVA,EAAA,KAAO,OACPA,EAAA,OAAS,SACTA,EAAA,OAAS,SACTA,EAAA,QAAU,UACVA,EAAA,OAAS,SACTA,EAAA,WAAa,cACbA,EAAA,YAAc,eACdA,EAAA,WAAa,aACbA,EAAA,KAAO,OACPA,EAAA,KAAO,OACPA,EAAA,KAAO,OACPA,EAAA,YAAc,eACdA,EAAA,cAAgB,kBAChBA,EAAA,YAAc,gBACdA,EAAA,YAAc,gBACdA,EAAA,YAAc,gBACdA,EAAA,YAAc,gBACdA,EAAA,cAAgB,kBAChBA,EAAA,aAAe,iBACfA,EAAA,eAAiB,mBACjBA,EAAA,eAAiB,mBACjBA,EAAA,iBAAmB,qBACnBA,EAAA,UAAY,aACZA,EAAA,cAAgB,kBAChBA,EAAA,eAAiB,mBACjBA,EAAA,IAAM,MACNA,EAAA,IAAM,MACNA,EAAA,IAAM,MACNA,EAAA,IAAM,MACNA,EAAA,OAAS,SACTA,EAAA,OAAS,SACTA,EAAA,MAAQ,QACRA,EAAA,KAAO,OACPA,EAAA,QAAU,UACVA,EAAA,aAAe,kBACfA,EAAA,gBAAkB,sBAClBA,EAAA,4BAA8B,mCAC9BA,EAAA,+BAAiC,uCACjCA,EAAA,iBAAmB,uBACnBA,EAAA,oBAAsB,2BACtBA,EAAA,oBAAsB,2BACtBA,EAAA,YAAc,iBACdA,EAAA,oBAAsB,2BACtBA,EAAA,qBAAuB,4BACvBA,EAAA,OAAS,SACTA,EAAA,MAAQ,WACRA,EAAA,WAAa,gBAEbA,EAAA,SAAW,aACXA,EAAA,YAAc,gBACdA,EAAA,WAAa,gBACbA,EAAA,SAAW,cACXA,EAAA,OAAS,WACTA,EAAA,SAAW,aACXA,EAAA,YAAc,iBACdA,EAAA,QAAU,aACVA,EAAA,WAAa,iBACbA,EAAA,YAAc,iBACdA,EAAA,SAAW,cACXA,EAAA,eAAiB,qBACjBA,EAAA,YAAc,kBA7DJA,IAAAA,GAAA,IAgEAC,GAAAA,IACVA,EAAAA,EAAA,YAAc,CAAC,EAAf,cACAA,EAAAA,EAAA,QAAU,CAAC,EAAX,UACAA,EAAAA,EAAA,eAAiB,CAAC,EAAlB,iBAEAA,EAAAA,EAAA,OAAS,CAAC,EAAV,SACAA,EAAAA,EAAA,SAAW,CAAC,EAAZ,WACAA,EAAAA,EAAA,oBAAsB,CAAC,EAAvB,sBACAA,EAAAA,EAAA,KAAO,CAAC,EAAR,OARUA,IAAAA,GAAA,IAWL,MAAMC,EAAgB,CAC3B,OAAQ,CAAE,MAAO,IAAK,MAAO,IAAK,YAAa,SAAU,aAAc,EAAM,EAC7E,aAAc,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,iBAAkB,aAAc,EAAM,EAC7F,aAAc,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,gBAAiB,aAAc,EAAK,EAC3F,kBAAmB,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,uBAAwB,aAAc,EAAK,EACvG,YAAa,CAAE,MAAO,IAAK,MAAO,IAAK,YAAa,eAAgB,aAAc,EAAM,EACxF,mBAAoB,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,2BAA4B,aAAc,EAAM,EAC7G,SAAU,CAAE,MAAO,IAAK,MAAO,IAAK,YAAa,YAAa,aAAc,EAAM,EAClF,gBAAiB,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,wBAAyB,aAAc,EAAM,EACvG,SAAU,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,WAAY,aAAc,EAAM,EACnF,eAAgB,CAAE,MAAO,KAAM,MAAO,KAAM,YAAa,mBAAoB,aAAc,EAAM,CACnG,C","sources":["webpack://grafana/./node_modules/@grafana/experimental/dist/esm/VisualQueryBuilder/types.js","webpack://grafana/./public/app/plugins/datasource/loki/languageUtils.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/components/LabelParamEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/operationUtils.ts","webpack://grafana/./public/app/plugins/datasource/loki/querybuilder/types.ts"],"sourcesContent":["var QueryEditorMode = /* @__PURE__ */ ((QueryEditorMode2) => {\n  QueryEditorMode2[\"Code\"] = \"code\";\n  QueryEditorMode2[\"Builder\"] = \"builder\";\n  return QueryEditorMode2;\n})(QueryEditorMode || {});\nconst BINARY_OPERATIONS_KEY = \"Binary operations\";\n\nexport { BINARY_OPERATIONS_KEY, QueryEditorMode };\n//# sourceMappingURL=types.js.map\n","import { invert } from 'lodash';\n\nimport { AbstractLabelMatcher, AbstractLabelOperator, AbstractQuery, DataFrame, TimeRange } from '@grafana/data';\n\nimport { LabelType } from './types';\n\nfunction roundMsToMin(milliseconds: number): number {\n  return roundSecToMin(milliseconds / 1000);\n}\n\nfunction roundSecToMin(seconds: number): number {\n  return Math.floor(seconds / 60);\n}\n\nexport function shouldRefreshLabels(range?: TimeRange, prevRange?: TimeRange): boolean {\n  if (range && prevRange) {\n    const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());\n    const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf());\n    // If both are same, don't need to refresh\n    return !(sameMinuteFrom && sameMinuteTo);\n  }\n  return false;\n}\n\n// Loki regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),\n// so every character that matches something in that list has to be escaped.\n// the list of meta characters is: *+?()|\\.[]{}^$\n// we make a javascript regular expression that matches those characters:\nconst RE2_METACHARACTERS = /[*+?()|\\\\.\\[\\]{}^$]/g;\nfunction escapeLokiRegexp(value: string): string {\n  return value.replace(RE2_METACHARACTERS, '\\\\$&');\n}\n\n// based on the openmetrics-documentation, the 3 symbols we have to handle are:\n// - \\n ... the newline character\n// - \\  ... the backslash character\n// - \"  ... the double-quote character\nexport function escapeLabelValueInExactSelector(labelValue: string): string {\n  return labelValue.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\"');\n}\n\nexport function unescapeLabelValue(labelValue: string): string {\n  return labelValue.replace(/\\\\n/g, '\\n').replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n}\n\nexport function escapeLabelValueInRegexSelector(labelValue: string): string {\n  return escapeLabelValueInExactSelector(escapeLokiRegexp(labelValue));\n}\n\nexport function escapeLabelValueInSelector(labelValue: string, selector?: string): string {\n  return isRegexSelector(selector)\n    ? escapeLabelValueInRegexSelector(labelValue)\n    : escapeLabelValueInExactSelector(labelValue);\n}\n\nexport function isRegexSelector(selector?: string) {\n  if (selector && (selector.includes('=~') || selector.includes('!~'))) {\n    return true;\n  }\n  return false;\n}\n\nexport function isBytesString(string: string) {\n  const BYTES_KEYWORDS = [\n    'b',\n    'kib',\n    'Kib',\n    'kb',\n    'KB',\n    'mib',\n    'Mib',\n    'mb',\n    'MB',\n    'gib',\n    'Gib',\n    'gb',\n    'GB',\n    'tib',\n    'Tib',\n    'tb',\n    'TB',\n    'pib',\n    'Pib',\n    'pb',\n    'PB',\n    'eib',\n    'Eib',\n    'eb',\n    'EB',\n  ];\n  const regex = new RegExp(`^(?:-?\\\\d+(?:\\\\.\\\\d+)?)(?:${BYTES_KEYWORDS.join('|')})$`);\n  const match = string.match(regex);\n  return !!match;\n}\n\nexport function getLabelTypeFromFrame(labelKey: string, frame?: DataFrame, index?: number): null | LabelType {\n  if (!frame || index === undefined) {\n    return null;\n  }\n\n  const typeField = frame.fields.find((field) => field.name === 'labelTypes')?.values[index];\n  if (!typeField) {\n    return null;\n  }\n  switch (typeField[labelKey]) {\n    case 'I':\n      return LabelType.Indexed;\n    case 'S':\n      return LabelType.StructuredMetadata;\n    case 'P':\n      return LabelType.Parsed;\n    default:\n      return null;\n  }\n}\n\nexport const mapOpToAbstractOp: Record<AbstractLabelOperator, string> = {\n  [AbstractLabelOperator.Equal]: '=',\n  [AbstractLabelOperator.NotEqual]: '!=',\n  [AbstractLabelOperator.EqualRegEx]: '=~',\n  [AbstractLabelOperator.NotEqualRegEx]: '!~',\n};\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-assertions\nexport const mapAbstractOperatorsToOp = invert(mapOpToAbstractOp) as Record<string, AbstractLabelOperator>;\n\nexport function abstractQueryToExpr(labelBasedQuery: AbstractQuery): string {\n  const expr = labelBasedQuery.labelMatchers\n    .map((selector: AbstractLabelMatcher) => {\n      const operator = mapOpToAbstractOp[selector.operator];\n      if (operator) {\n        return `${selector.name}${operator}\"${selector.value}\"`;\n      } else {\n        return '';\n      }\n    })\n    .filter((e: string) => e !== '')\n    .join(', ');\n\n  return expr ? `{${expr}}` : '';\n}\n\nexport function processLabels(labels: Array<{ [key: string]: string }>) {\n  const valueSet: { [key: string]: Set<string> } = {};\n  labels.forEach((label) => {\n    Object.keys(label).forEach((key) => {\n      if (!valueSet[key]) {\n        valueSet[key] = new Set();\n      }\n      if (!valueSet[key].has(label[key])) {\n        valueSet[key].add(label[key]);\n      }\n    });\n  });\n\n  const valueArray: { [key: string]: string[] } = {};\n  limitSuggestions(Object.keys(valueSet)).forEach((key) => {\n    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));\n  });\n\n  return { values: valueArray, keys: Object.keys(valueArray) };\n}\n\n// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.\nexport const SUGGESTIONS_LIMIT = 10000;\nexport function limitSuggestions(items: string[]) {\n  return items.slice(0, SUGGESTIONS_LIMIT);\n}\n","import React, { useState } from 'react';\n\nimport { DataSourceApi, SelectableValue } from '@grafana/data';\nimport {\n  QueryBuilderLabelFilter,\n  QueryBuilderOperationParamEditorProps,\n  QueryBuilderOperationParamValue,\n  VisualQuery,\n  VisualQueryModeller,\n} from '@grafana/experimental';\nimport { Select } from '@grafana/ui';\n\nimport { getOperationParamId } from '../operationUtils';\n\nexport const LabelParamEditor = ({\n  onChange,\n  index,\n  operationId,\n  value,\n  query,\n  datasource,\n  queryModeller,\n}: QueryBuilderOperationParamEditorProps) => {\n  const [state, setState] = useState<{\n    options?: SelectableValue[];\n    isLoading?: boolean;\n  }>({});\n\n  return (\n    <Select<QueryBuilderOperationParamValue | undefined>\n      inputId={getOperationParamId(operationId, index)}\n      autoFocus={value === ''}\n      openMenuOnFocus\n      onOpenMenu={async () => {\n        setState({ isLoading: true });\n        const options = await loadGroupByLabels(query, datasource, queryModeller);\n        setState({ options, isLoading: undefined });\n      }}\n      isLoading={state.isLoading}\n      allowCustomValue\n      noOptionsMessage=\"No labels found\"\n      loadingMessage=\"Loading labels\"\n      options={state.options}\n      value={toOption(value)}\n      onChange={(value) => onChange(index, value.value!)}\n    />\n  );\n};\n\nasync function loadGroupByLabels(\n  query: VisualQuery,\n  datasource: DataSourceApi,\n  queryModeller: VisualQueryModeller\n): Promise<SelectableValue[]> {\n  let labels: QueryBuilderLabelFilter[] = query.labels;\n\n  const queryString = queryModeller.renderLabels(labels);\n  const result = await datasource.languageProvider.fetchSeriesLabels(queryString);\n\n  return Object.keys(result).map((x) => ({\n    label: x,\n    value: x,\n  }));\n}\n\nconst toOption = (\n  value: QueryBuilderOperationParamValue | undefined\n): SelectableValue<QueryBuilderOperationParamValue | undefined> => ({ label: value?.toString(), value });\n","import { capitalize } from 'lodash';\nimport pluralize from 'pluralize';\n\nimport {\n  QueryBuilderOperation,\n  QueryBuilderOperationDefinition,\n  QueryBuilderOperationParamDef,\n  QueryBuilderOperationParamValue,\n  VisualQuery,\n  VisualQueryModeller,\n} from '@grafana/experimental';\n\nimport { escapeLabelValueInExactSelector } from '../languageUtils';\nimport { FUNCTIONS } from '../syntax';\n\nimport { LabelParamEditor } from './components/LabelParamEditor';\nimport { LokiOperationId, LokiOperationOrder, LokiVisualQuery, LokiVisualQueryOperationCategory } from './types';\n\nexport function createRangeOperation(\n  name: string,\n  isRangeOperationWithGrouping?: boolean\n): QueryBuilderOperationDefinition {\n  const params = [getRangeVectorParamDef()];\n  const defaultParams = ['$__auto'];\n  let paramChangedHandler = undefined;\n\n  if (name === LokiOperationId.QuantileOverTime) {\n    defaultParams.push('0.95');\n    params.push({\n      name: 'Quantile',\n      type: 'number',\n    });\n  }\n\n  if (isRangeOperationWithGrouping) {\n    params.push({\n      name: 'By label',\n      type: 'string',\n      restParam: true,\n      optional: true,\n    });\n\n    paramChangedHandler = getOnLabelAddedHandler(`__${name}_by`);\n  }\n\n  return {\n    id: name,\n    name: getLokiOperationDisplayName(name),\n    params: params,\n    defaultParams,\n    alternativesKey: 'range function',\n    category: LokiVisualQueryOperationCategory.RangeFunctions,\n    orderRank: LokiOperationOrder.RangeVectorFunction,\n    renderer: operationWithRangeVectorRenderer,\n    addOperationHandler: addLokiOperation,\n    paramChangedHandler,\n    explainHandler: (op, def) => {\n      let opDocs = FUNCTIONS.find((x) => x.insertText === op.id)?.documentation ?? '';\n\n      if (op.params[0] === '$__auto') {\n        return `${opDocs} \\`$__auto\\` is a variable that will be replaced with the [value of step](https://grafana.com/docs/grafana/next/datasources/loki/query-editor/#options) for range queries and with the value of the selected time range (calculated to - from) for instant queries.`;\n      } else {\n        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \\`${op.params[0]}\\`.`;\n      }\n    },\n  };\n}\n\nexport function createRangeOperationWithGrouping(name: string): QueryBuilderOperationDefinition[] {\n  const rangeOperation = createRangeOperation(name, true);\n  // Copy range operation params without the last param\n  const params = rangeOperation.params.slice(0, -1);\n  const operations: QueryBuilderOperationDefinition[] = [\n    rangeOperation,\n    {\n      id: `__${name}_by`,\n      name: `${getLokiOperationDisplayName(name)} by`,\n      params: [\n        ...params,\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [...rangeOperation.defaultParams, ''],\n      alternativesKey: 'range function with grouping',\n      category: LokiVisualQueryOperationCategory.RangeFunctions,\n      renderer: getRangeAggregationWithGroupingRenderer(name, 'by'),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'by'),\n      addOperationHandler: addLokiOperation,\n      hideFromList: true,\n    },\n    {\n      id: `__${name}_without`,\n      name: `${getLokiOperationDisplayName(name)} without`,\n      params: [\n        ...params,\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [...rangeOperation.defaultParams, ''],\n      alternativesKey: 'range function with grouping',\n      category: LokiVisualQueryOperationCategory.RangeFunctions,\n      renderer: getRangeAggregationWithGroupingRenderer(name, 'without'),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'without'),\n      addOperationHandler: addLokiOperation,\n      hideFromList: true,\n    },\n  ];\n\n  return operations;\n}\n\nexport function getRangeAggregationWithGroupingRenderer(aggregation: string, grouping: 'by' | 'without') {\n  return function aggregationRenderer(\n    model: QueryBuilderOperation,\n    def: QueryBuilderOperationDefinition,\n    innerExpr: string\n  ) {\n    const restParamIndex = def.params.findIndex((param) => param.restParam);\n    const params = model.params.slice(0, restParamIndex);\n    const restParams = model.params.slice(restParamIndex);\n\n    if (params.length === 2 && aggregation === LokiOperationId.QuantileOverTime) {\n      return `${aggregation}(${params[1]}, ${innerExpr} [${params[0]}]) ${grouping} (${restParams.join(', ')})`;\n    }\n\n    return `${aggregation}(${innerExpr} [${params[0]}]) ${grouping} (${restParams.join(', ')})`;\n  };\n}\n\nfunction operationWithRangeVectorRenderer(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDefinition,\n  innerExpr: string\n) {\n  const params = model.params ?? [];\n  const rangeVector = params[0] ?? '$__auto';\n  // QuantileOverTime is only range vector with more than one param\n  if (params.length === 2 && model.id === LokiOperationId.QuantileOverTime) {\n    const quantile = params[1];\n    return `${model.id}(${quantile}, ${innerExpr} [${rangeVector}])`;\n  }\n\n  return `${model.id}(${innerExpr} [${params[0] ?? '$__auto'}])`;\n}\n\nexport function labelFilterRenderer(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDefinition,\n  innerExpr: string\n) {\n  const integerOperators = ['<', '<=', '>', '>='];\n\n  if (integerOperators.includes(String(model.params[1]))) {\n    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;\n  }\n\n  return `${innerExpr} | ${model.params[0]} ${model.params[1]} \\`${model.params[2]}\\``;\n}\n\nexport function isConflictingFilter(\n  operation: QueryBuilderOperation,\n  queryOperations: QueryBuilderOperation[]\n): boolean {\n  if (!operation) {\n    return false;\n  }\n  const operationIsNegative = operation.params[1].toString().startsWith('!');\n\n  const candidates = queryOperations.filter(\n    (queryOperation) =>\n      queryOperation.id === LokiOperationId.LabelFilter &&\n      queryOperation.params[0] === operation.params[0] &&\n      queryOperation.params[2] === operation.params[2]\n  );\n\n  const conflict = candidates.some((candidate) => {\n    if (operationIsNegative && candidate.params[1].toString().startsWith('!') === false) {\n      return true;\n    }\n    if (operationIsNegative === false && candidate.params[1].toString().startsWith('!')) {\n      return true;\n    }\n    return false;\n  });\n\n  return conflict;\n}\n\nexport function pipelineRenderer(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDefinition,\n  innerExpr: string\n) {\n  switch (model.id) {\n    case LokiOperationId.Logfmt:\n      const [strict = false, keepEmpty = false, ...labels] = model.params;\n      return `${innerExpr} | logfmt${strict ? ' --strict' : ''}${keepEmpty ? ' --keep-empty' : ''} ${labels\n        .filter((label) => label)\n        .join(', ')}`.trim();\n    case LokiOperationId.Json:\n      return `${innerExpr} | json ${model.params.filter((param) => param).join(', ')}`.trim();\n    case LokiOperationId.Drop:\n      return `${innerExpr} | drop ${model.params.filter((param) => param).join(', ')}`.trim();\n    case LokiOperationId.Keep:\n      return `${innerExpr} | keep ${model.params.filter((param) => param).join(', ')}`.trim();\n    default:\n      return `${innerExpr} | ${model.id}`;\n  }\n}\n\nfunction isRangeVectorFunction(def: QueryBuilderOperationDefinition) {\n  return def.category === LokiVisualQueryOperationCategory.RangeFunctions;\n}\n\nfunction getIndexOfOrLast(\n  operations: QueryBuilderOperation[],\n  queryModeller: VisualQueryModeller,\n  condition: (def: QueryBuilderOperationDefinition) => boolean\n) {\n  const index = operations.findIndex((x) => {\n    const opDef = queryModeller.getOperationDefinition(x.id);\n    if (!opDef) {\n      return false;\n    }\n    return condition(opDef);\n  });\n\n  return index === -1 ? operations.length : index;\n}\n\nexport function addLokiOperation(\n  def: QueryBuilderOperationDefinition,\n  query: LokiVisualQuery,\n  modeller: VisualQueryModeller\n): LokiVisualQuery {\n  const newOperation: QueryBuilderOperation = {\n    id: def.id,\n    params: def.defaultParams,\n  };\n\n  const operations = [...query.operations];\n\n  const existingRangeVectorFunction = operations.find((x) => {\n    const opDef = modeller.getOperationDefinition(x.id);\n    if (!opDef) {\n      return false;\n    }\n    return isRangeVectorFunction(opDef);\n  });\n\n  switch (def.category) {\n    case LokiVisualQueryOperationCategory.Aggregations:\n    case LokiVisualQueryOperationCategory.Functions:\n      // If we are adding a function but we have not range vector function yet add one\n      if (!existingRangeVectorFunction) {\n        const placeToInsert = getIndexOfOrLast(\n          operations,\n          modeller,\n          (def) => def.category === LokiVisualQueryOperationCategory.Functions\n        );\n        operations.splice(placeToInsert, 0, { id: LokiOperationId.Rate, params: ['$__auto'] });\n      }\n      operations.push(newOperation);\n      break;\n    case LokiVisualQueryOperationCategory.RangeFunctions:\n      // If adding a range function and range function is already added replace it\n      if (existingRangeVectorFunction) {\n        const index = operations.indexOf(existingRangeVectorFunction);\n        operations[index] = newOperation;\n        break;\n      }\n\n    // Add range functions after any formats, line filters and label filters\n    default:\n      const placeToInsert = getIndexOfOrLast(\n        operations,\n        modeller,\n        (x) => (def.orderRank ?? 100) < (x.orderRank ?? 100)\n      );\n      operations.splice(placeToInsert, 0, newOperation);\n      break;\n  }\n\n  return {\n    ...query,\n    operations,\n  };\n}\n\nexport function addNestedQueryHandler(def: QueryBuilderOperationDefinition, query: LokiVisualQuery): LokiVisualQuery {\n  return {\n    ...query,\n    binaryQueries: [\n      ...(query.binaryQueries ?? []),\n      {\n        operator: '/',\n        query,\n      },\n    ],\n  };\n}\n\nexport function getLineFilterRenderer(operation: string, caseInsensitive?: boolean) {\n  return function lineFilterRenderer(\n    model: QueryBuilderOperation,\n    def: QueryBuilderOperationDefinition,\n    innerExpr: string\n  ) {\n    const hasBackticks = model.params.some((param) => typeof param === 'string' && param.includes('`'));\n    const delimiter = hasBackticks ? '\"' : '`';\n    let params;\n    if (hasBackticks) {\n      params = model.params.map((param) =>\n        typeof param === 'string' ? escapeLabelValueInExactSelector(param) : param\n      );\n    } else {\n      params = model.params;\n    }\n    if (caseInsensitive) {\n      return `${innerExpr} ${operation} ${delimiter}(?i)${params.join(`${delimiter} or ${delimiter}(?i)`)}${delimiter}`;\n    }\n    return `${innerExpr} ${operation} ${delimiter}${params.join(`${delimiter} or ${delimiter}`)}${delimiter}`;\n  };\n}\nfunction getRangeVectorParamDef(): QueryBuilderOperationParamDef {\n  return {\n    name: 'Range',\n    type: 'string',\n    options: ['$__auto', '1m', '5m', '10m', '1h', '24h'],\n  };\n}\n\nexport function getOperationParamId(operationId: string, paramIndex: number) {\n  return `operations.${operationId}.param.${paramIndex}`;\n}\n\nexport function getOnLabelAddedHandler(changeToOperationId: string) {\n  return function onParamChanged(index: number, op: QueryBuilderOperation, def: QueryBuilderOperationDefinition) {\n    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the\n    // case of just simple aggregation without label. When user adds the label it now has the same number of params\n    // as its definition, and now we can change it to its `_by` variant.\n    if (op.params.length === def.params.length) {\n      return {\n        ...op,\n        id: changeToOperationId,\n      };\n    }\n    return op;\n  };\n}\n\n/**\n * Very simple poc implementation, needs to be modified to support all aggregation operators\n */\nexport function getAggregationExplainer(aggregationName: string, mode: 'by' | 'without' | '') {\n  return function aggregationExplainer(model: QueryBuilderOperation) {\n    const labels = model.params.map((label) => `\\`${label}\\``).join(' and ');\n    const labelWord = pluralize('label', model.params.length);\n\n    switch (mode) {\n      case 'by':\n        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;\n      case 'without':\n        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;\n      default:\n        return `Calculates ${aggregationName} over the dimensions.`;\n    }\n  };\n}\n\n/**\n * This function will transform operations without labels to their plan aggregation operation\n */\nexport function getLastLabelRemovedHandler(changeToOperationId: string) {\n  return function onParamChanged(index: number, op: QueryBuilderOperation, def: QueryBuilderOperationDefinition) {\n    // If definition has more params then is defined there are no optional rest params anymore.\n    // We then transform this operation into a different one\n    if (op.params.length < def.params.length) {\n      return {\n        ...op,\n        id: changeToOperationId,\n      };\n    }\n\n    return op;\n  };\n}\n\nexport function getLokiOperationDisplayName(funcName: string) {\n  return capitalize(funcName.replace(/_/g, ' '));\n}\n\nexport function defaultAddOperationHandler<T extends VisualQuery>(def: QueryBuilderOperationDefinition, query: T) {\n  const newOperation: QueryBuilderOperation = {\n    id: def.id,\n    params: def.defaultParams,\n  };\n\n  return {\n    ...query,\n    operations: [...query.operations, newOperation],\n  };\n}\n\nexport function createAggregationOperation(\n  name: string,\n  overrides: Partial<QueryBuilderOperationDefinition> = {}\n): QueryBuilderOperationDefinition[] {\n  const operations: QueryBuilderOperationDefinition[] = [\n    {\n      id: name,\n      name: getLokiOperationDisplayName(name),\n      params: [\n        {\n          name: 'By label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n        },\n      ],\n      defaultParams: [],\n      alternativesKey: 'plain aggregations',\n      category: LokiVisualQueryOperationCategory.Aggregations,\n      renderer: functionRendererLeft,\n      paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),\n      explainHandler: getAggregationExplainer(name, ''),\n      addOperationHandler: defaultAddOperationHandler,\n      ...overrides,\n    },\n    {\n      id: `__${name}_by`,\n      name: `${getLokiOperationDisplayName(name)} by`,\n      params: [\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'aggregations by',\n      category: LokiVisualQueryOperationCategory.Aggregations,\n      renderer: getAggregationByRenderer(name),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'by'),\n      addOperationHandler: defaultAddOperationHandler,\n      hideFromList: true,\n      ...overrides,\n    },\n    {\n      id: `__${name}_without`,\n      name: `${getLokiOperationDisplayName(name)} without`,\n      params: [\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'aggregations by',\n      category: LokiVisualQueryOperationCategory.Aggregations,\n      renderer: getAggregationWithoutRenderer(name),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'without'),\n      addOperationHandler: defaultAddOperationHandler,\n      hideFromList: true,\n      ...overrides,\n    },\n  ];\n\n  return operations;\n}\n\nfunction getAggregationWithoutRenderer(aggregation: string) {\n  return function aggregationRenderer(\n    model: QueryBuilderOperation,\n    def: QueryBuilderOperationDefinition,\n    innerExpr: string\n  ) {\n    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;\n  };\n}\n\nexport function functionRendererLeft(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDefinition,\n  innerExpr: string\n) {\n  const params = renderParams(model, def, innerExpr);\n  const str = model.id + '(';\n\n  if (innerExpr) {\n    params.push(innerExpr);\n  }\n\n  return str + params.join(', ') + ')';\n}\n\nfunction renderParams(model: QueryBuilderOperation, def: QueryBuilderOperationDefinition, innerExpr: string) {\n  return (model.params ?? []).map((value, index) => {\n    const paramDef = def.params[index];\n    if (paramDef.type === 'string') {\n      return '\"' + value + '\"';\n    }\n\n    return value;\n  });\n}\n\nfunction getAggregationByRenderer(aggregation: string) {\n  return function aggregationRenderer(\n    model: QueryBuilderOperation,\n    def: QueryBuilderOperationDefinition,\n    innerExpr: string\n  ) {\n    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;\n  };\n}\n\nexport function createAggregationOperationWithParam(\n  name: string,\n  paramsDef: { params: QueryBuilderOperationParamDef[]; defaultParams: QueryBuilderOperationParamValue[] },\n  overrides: Partial<QueryBuilderOperationDefinition> = {}\n): QueryBuilderOperationDefinition[] {\n  const operations = createAggregationOperation(name, overrides);\n  operations[0].params.unshift(...paramsDef.params);\n  operations[1].params.unshift(...paramsDef.params);\n  operations[2].params.unshift(...paramsDef.params);\n  operations[0].defaultParams = paramsDef.defaultParams;\n  operations[1].defaultParams = [...paramsDef.defaultParams, ''];\n  operations[2].defaultParams = [...paramsDef.defaultParams, ''];\n  operations[1].renderer = getAggregationByRendererWithParameter(name);\n  operations[2].renderer = getAggregationByRendererWithParameter(name);\n  return operations;\n}\n\nfunction getAggregationByRendererWithParameter(aggregation: string) {\n  return function aggregationRenderer(\n    model: QueryBuilderOperation,\n    def: QueryBuilderOperationDefinition,\n    innerExpr: string\n  ) {\n    const restParamIndex = def.params.findIndex((param) => param.restParam);\n    const params = model.params.slice(0, restParamIndex);\n    const restParams = model.params.slice(restParamIndex);\n\n    return `${aggregation} by(${restParams.join(', ')}) (${params\n      .map((param, idx) => (def.params[idx].type === 'string' ? `\\\"${param}\\\"` : param))\n      .join(', ')}, ${innerExpr})`;\n  };\n}\n","import {\n  VisualQueryBinary,\n  QueryBuilderLabelFilter,\n  QueryBuilderOperation,\n  BINARY_OPERATIONS_KEY,\n} from '@grafana/experimental';\n\n/**\n * Visual query model\n */\nexport interface LokiVisualQuery {\n  labels: QueryBuilderLabelFilter[];\n  operations: QueryBuilderOperation[];\n  binaryQueries?: LokiVisualQueryBinary[];\n}\n\nexport type LokiVisualQueryBinary = VisualQueryBinary<LokiVisualQuery>;\nexport enum LokiQueryPatternType {\n  Log = 'log',\n  Metric = 'metric',\n}\n\nexport interface LokiQueryPattern {\n  name: string;\n  operations: QueryBuilderOperation[];\n  type: LokiQueryPatternType;\n}\n\nexport enum LokiVisualQueryOperationCategory {\n  Aggregations = 'Aggregations',\n  RangeFunctions = 'Range functions',\n  Functions = 'Functions',\n  Formats = 'Formats',\n  LineFilters = 'Line filters',\n  LabelFilters = 'Label filters',\n  BinaryOps = BINARY_OPERATIONS_KEY,\n}\n\nexport enum LokiOperationId {\n  Json = 'json',\n  Logfmt = 'logfmt',\n  Regexp = 'regexp',\n  Pattern = 'pattern',\n  Unpack = 'unpack',\n  LineFormat = 'line_format',\n  LabelFormat = 'label_format',\n  Decolorize = 'decolorize',\n  Drop = 'drop',\n  Keep = 'keep',\n  Rate = 'rate',\n  RateCounter = 'rate_counter',\n  CountOverTime = 'count_over_time',\n  SumOverTime = 'sum_over_time',\n  AvgOverTime = 'avg_over_time',\n  MaxOverTime = 'max_over_time',\n  MinOverTime = 'min_over_time',\n  FirstOverTime = 'first_over_time',\n  LastOverTime = 'last_over_time',\n  StdvarOverTime = 'stdvar_over_time',\n  StddevOverTime = 'stddev_over_time',\n  QuantileOverTime = 'quantile_over_time',\n  BytesRate = 'bytes_rate',\n  BytesOverTime = 'bytes_over_time',\n  AbsentOverTime = 'absent_over_time',\n  Sum = 'sum',\n  Avg = 'avg',\n  Min = 'min',\n  Max = 'max',\n  Stddev = 'stddev',\n  Stdvar = 'stdvar',\n  Count = 'count',\n  TopK = 'topk',\n  BottomK = 'bottomk',\n  LineContains = '__line_contains',\n  LineContainsNot = '__line_contains_not',\n  LineContainsCaseInsensitive = '__line_contains_case_insensitive',\n  LineContainsNotCaseInsensitive = '__line_contains_not_case_insensitive',\n  LineMatchesRegex = '__line_matches_regex',\n  LineMatchesRegexNot = '__line_matches_regex_not',\n  LineFilterIpMatches = '__line_filter_ip_matches',\n  LabelFilter = '__label_filter',\n  LabelFilterNoErrors = '__label_filter_no_errors',\n  LabelFilterIpMatches = '__label_filter_ip_marches',\n  Unwrap = 'unwrap',\n  SumBy = '__sum_by',\n  SumWithout = '__sum_without',\n  // Binary ops\n  Addition = '__addition',\n  Subtraction = '__subtraction',\n  MultiplyBy = '__multiply_by',\n  DivideBy = '__divide_by',\n  Modulo = '__modulo',\n  Exponent = '__exponent',\n  NestedQuery = '__nested_query',\n  EqualTo = '__equal_to',\n  NotEqualTo = '__not_equal_to',\n  GreaterThan = '__greater_than',\n  LessThan = '__less_than',\n  GreaterOrEqual = '__greater_or_equal',\n  LessOrEqual = '__less_or_equal',\n}\n\nexport enum LokiOperationOrder {\n  LineFilters = 1,\n  Parsers = 2,\n  PipeOperations = 3,\n  // Unwrap is a special case, as it is usually the last operation, so the order is after pipeOperations\n  Unwrap = 4,\n  NoErrors = 5,\n  RangeVectorFunction = 5,\n  Last = 6,\n}\n\nexport const lokiOperators = {\n  equals: { label: '=', value: '=', description: 'Equals', isMultiValue: false },\n  doesNotEqual: { label: '!=', value: '!=', description: 'Does not equal', isMultiValue: false },\n  matchesRegex: { label: '=~', value: '=~', description: 'Matches regex', isMultiValue: true },\n  doesNotMatchRegex: { label: '!~', value: '!~', description: 'Does not match regex', isMultiValue: true },\n  greaterThan: { label: '>', value: '>', description: 'Greater than', isMultiValue: false },\n  greaterThanOrEqual: { label: '>=', value: '>=', description: 'Greater than or equal to', isMultiValue: false },\n  lessThan: { label: '<', value: '<', description: 'Less than', isMultiValue: false },\n  lessThanOrEqual: { label: '<=', value: '<=', description: 'Less than or equal to', isMultiValue: false },\n  contains: { label: '|=', value: '|=', description: 'Contains', isMultiValue: false },\n  doesNotContain: { label: '!=', value: '!=', description: 'Does not contain', isMultiValue: false },\n};\n"],"names":["QueryEditorMode","QueryEditorMode2","BINARY_OPERATIONS_KEY","roundMsToMin","milliseconds","roundSecToMin","seconds","shouldRefreshLabels","range","prevRange","sameMinuteFrom","sameMinuteTo","RE2_METACHARACTERS","escapeLokiRegexp","value","escapeLabelValueInExactSelector","labelValue","unescapeLabelValue","escapeLabelValueInRegexSelector","escapeLabelValueInSelector","selector","isRegexSelector","isBytesString","string","BYTES_KEYWORDS","regex","getLabelTypeFromFrame","labelKey","frame","index","typeField","field","mapOpToAbstractOp","mapAbstractOperatorsToOp","abstractQueryToExpr","labelBasedQuery","expr","operator","e","processLabels","labels","valueSet","label","key","valueArray","limitSuggestions","SUGGESTIONS_LIMIT","items","LabelParamEditor","onChange","operationId","query","datasource","queryModeller","state","setState","Select","getOperationParamId","options","loadGroupByLabels","toOption","queryString","result","x","createRangeOperation","name","isRangeOperationWithGrouping","params","getRangeVectorParamDef","defaultParams","paramChangedHandler","getOnLabelAddedHandler","getLokiOperationDisplayName","operationWithRangeVectorRenderer","addLokiOperation","op","def","opDocs","createRangeOperationWithGrouping","rangeOperation","getRangeAggregationWithGroupingRenderer","getLastLabelRemovedHandler","getAggregationExplainer","aggregation","grouping","model","innerExpr","restParamIndex","param","restParams","rangeVector","quantile","labelFilterRenderer","isConflictingFilter","operation","queryOperations","operationIsNegative","queryOperation","candidate","pipelineRenderer","strict","keepEmpty","isRangeVectorFunction","getIndexOfOrLast","operations","condition","opDef","modeller","newOperation","existingRangeVectorFunction","placeToInsert","addNestedQueryHandler","getLineFilterRenderer","caseInsensitive","hasBackticks","delimiter","paramIndex","changeToOperationId","aggregationName","mode","labelWord","funcName","defaultAddOperationHandler","createAggregationOperation","overrides","functionRendererLeft","getAggregationByRenderer","getAggregationWithoutRenderer","renderParams","str","createAggregationOperationWithParam","paramsDef","getAggregationByRendererWithParameter","idx","LokiQueryPatternType","LokiVisualQueryOperationCategory","LokiOperationId","LokiOperationOrder","lokiOperators"],"sourceRoot":""}